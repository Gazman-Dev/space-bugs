- Purpose: Handles the main game logic and loop, ensuring smooth gameplay by managing updates, rendering, and player interactions.
- Imports:
  - import pygame
  - import configs.config
  - import game.player
  - import game.enemy
  - import game.bullet
- Definitions:
  - Classes:
    - Game:
      - Attributes:
        - screen: The display surface for rendering the game.
        - clock: Controls game update intervals.
        - player: Instance of Player class.
        - enemies: List containing instances of Enemy class.
        - bullets: List of Bullet instances on screen.
        - running: Boolean indicating the game's running state.
      - Methods:
        - setup():
          - Instantiate and position game elements such as player and enemies; utilize Vector2 for positions.
        - game_loop():
          - Execute continuously while the game is running:
            - Call handle_events() to handle user input.
            - Invoke update() to refresh game state, including player, enemies, and bullets.
            - Employ check_collisions() to identify and manage intersections between objects.
            - Use render() to update the display with drawn game elements.
            - Employ clock control to maintain consistent frame rate.
        - check_collisions():
          - Detect and respond to any bullet interactions with targets, updating states as necessary.
        - update():
          - Refreshes positions and statuses of all relevant game objects, ensuring each is interactive.
            - Update player by calling its internal methods.
            - Update enemies, moving and managing activities.
            - Manage bullets' trajectories and states.
        - render():
          - Prepare the display surface and render all game elements, including player, enemies, and bullets.
            - Clear the screen at the beginning of each frame.
            - Use each classâ€™s draw method to render its current state.
        - handle_events():
          - Capture and process user input actions like keyboard presses and mouse activity.

Adding detailed update and rendering methods allows each game component to handle its own changes and display in a cohesive and organized manner during the game loop. This separation supports readability and maintainability of game code by clearly defining and isolating responsibilities.